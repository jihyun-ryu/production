<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Speech Recording Experiment</title>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.0.0/css/jspsych.css">
  <script src="https://unpkg.com/jspsych@8.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.0.0"></script>
  <style>
    .recording-container {
      text-align: center;
      padding: 40px;
      max-width: 800px;
      margin: 0 auto;
    }
    .sentence-display {
      font-size: 28px;
      font-weight: bold;
      padding: 30px;
      margin: 30px 0;
      background: #f0f0f0;
      border-radius: 10px;
      line-height: 1.6;
    }
    .recording-status {
      font-size: 20px;
      margin: 20px 0;
      min-height: 30px;
    }
    .recording-active {
      color: #dc3545;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    .timer {
      font-size: 24px;
      font-weight: bold;
      margin: 15px 0;
    }
    .control-buttons {
      margin-top: 30px;
    }
    .control-buttons button {
      font-size: 18px;
      padding: 15px 40px;
      margin: 0 10px;
      cursor: pointer;
    }
    .record-btn {
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .record-btn:hover:not(:disabled) {
      background-color: #c82333;
    }
    .stop-btn {
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .stop-btn:hover:not(:disabled) {
      background-color: #218838;
    }
    .next-btn {
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .next-btn:hover:not(:disabled) {
      background-color: #0069d9;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .form-container {
      text-align: left;
      max-width: 500px;
      margin: 0 auto;
    }
    .form-container p {
      margin: 15px 0;
    }
    .form-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .form-container input[type="text"] {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .form-container input[type="radio"] {
      margin: 0 5px 0 15px;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>
  
  <script>
    /******************************************************
     * Speech Recording Experiment - Fixed Version
     ******************************************************/

    console.log('Script starting...');

    /* ===== CONFIG ===== */
    const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbwXiNBLuEwxLSztWek6zC6rrIMJWWTeK3pveJLluFoJMuufwYeZnGyn0Lbh2rz5en6Apg/exec';

    /* ===== UI TEXTS ===== */
    const TEXTS = {
      welcomeTitle: 'Speech Recording Experiment',
      welcomeBody: 'í™”ë©´ì— í‘œì‹œë˜ëŠ” ë¬¸ì¥ì„ ìì—°ìŠ¤ëŸ½ê²Œ ì½ì–´ì£¼ì„¸ìš”.<br><strong>ì¡°ìš©í•œ í™˜ê²½ì—ì„œ ì§„í–‰í•´ì£¼ì„¸ìš”.</strong>',
      startBtn: 'Start',
      ready: 'ì¤€ë¹„ë˜ë©´ ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”',
      recording: 'ğŸ”´ ë…¹ìŒ ì¤‘...',
      stopped: 'ë…¹ìŒì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.',
      recordBtn: 'ë…¹ìŒ ì‹œì‘',
      stopBtn: 'ë…¹ìŒ ì™„ë£Œ',
      nextBtn: 'ë‹¤ìŒ',
      endTitle: 'ê°ì‚¬í•©ë‹ˆë‹¤!',
      endBody: 'ì‹¤í—˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.',
      finishBtn: 'ì¢…ë£Œ'
    };

    /* ===== SENTENCES TO RECORD ===== */
    const SENTENCES = [
      "ì•ˆë…•",
      "ì˜ê°€"
    ];

    /* ===== GLOBAL STATE ===== */
    let mediaRecorder = null;
    let audioChunks = [];
    let participantId = null;
    let demographicsData = null;
    let currentTimerInterval = null;
    let isRecording = false;

    /* ===== INIT ===== */
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: () => {
        console.log('Experiment finished');
      }
    });

    /* ===== WELCOME ===== */
    const welcome = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.welcomeTitle}</h2><p>${TEXTS.welcomeBody}</p>`,
      choices: [TEXTS.startBtn]
    };

    /* ===== DEMOGRAPHICS - ë¨¼ì € ë°›ê¸° ===== */
    const demographics = {
      type: jsPsychSurveyHtmlForm,
      preamble: '<h3>ì°¸ê°€ì ì •ë³´</h3><p>ì‹¤í—˜ì„ ì‹œì‘í•˜ê¸° ì „ì— ì•„ë˜ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</p>',
      html: `
        <div class="form-container">
          <p>
            <label for="gender">ì„±ë³„:</label>
            <input type="radio" name="gender" value="ë‚¨" required> ë‚¨
            <input type="radio" name="gender" value="ì—¬" required> ì—¬
          </p>
          
          <p>
            <label for="birth_year">íƒœì–´ë‚œ í•´:</label>
            <input type="text" id="birth_year" name="birth_year" placeholder="YYYY (ì˜ˆ: 1995)" pattern="[0-9]{4}" required style="width: 150px;">
          </p>
          
          <p>
            <label for="birth_month">íƒœì–´ë‚œ ì›”:</label>
            <input type="text" id="birth_month" name="birth_month" placeholder="MM (ì˜ˆ: 03)" pattern="[0-9]{1,2}" required style="width: 80px;">
          </p>
          
          <p>
            <label for="native_lang">ëª¨êµ­ì–´:</label>
            <input type="text" id="native_lang" name="native_lang" placeholder="ì˜ˆ: í•œêµ­ì–´" required style="width: 200px;">
          </p>
          
          <p>
            <label for="dialect">ë°©ì–¸:</label>
            <input type="text" id="dialect" name="dialect" placeholder="ì˜ˆ: ì„œìš¸, ê²½ìƒë„" style="width: 200px;">
          </p>
          
          <p>
            <label for="foreign_lang">ì™¸êµ­ì–´:</label>
            <input type="text" id="foreign_lang" name="foreign_lang" placeholder="ì˜ˆ: ì˜ì–´, ì¼ë³¸ì–´" style="width: 300px;">
          </p>
        </div>
      `,
      button_label: 'ë…¹ìŒ ì‹œì‘í•˜ê¸°',
      data: { task: 'demographics' },
      on_finish: (data) => {
        // Demographics ë°ì´í„°ë¥¼ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
        demographicsData = data.response;
        participantId = 'P' + Date.now();
        data.participant_id = participantId;
        data.timestamp = new Date().toISOString();
        
        console.log('=== Demographics saved ===');
        console.log('Participant ID:', participantId);
        console.log('Demographics:', demographicsData);
      }
    };

    /* ===== MICROPHONE PERMISSION ===== */
    const mic_permission = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<h3>ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</h3><p>ë…¹ìŒì„ ìœ„í•´ ë§ˆì´í¬ ì‚¬ìš©ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.</p>',
      choices: ['ë§ˆì´í¬ í—ˆìš©'],
      on_finish: async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(track => track.stop());
          console.log('Microphone permission granted');
        } catch (err) {
          alert('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í—ˆìš©í•´ì£¼ì„¸ìš”.');
          console.error('Microphone error:', err);
        }
      }
    };

    /* ===== RECORDING TRIAL FACTORY ===== */
    function makeRecordingTrial(sentence, index) {
      return {
        type: jsPsychHtmlButtonResponse,
        stimulus: () => {
          return `
            <div class="recording-container">
              <div class="sentence-display">${sentence}</div>
              <div class="recording-status" id="status">${TEXTS.ready}</div>
              <div class="timer" id="timer"></div>
              <div class="control-buttons">
                <button class="record-btn" id="recordBtn" onclick="handleRecord()">${TEXTS.recordBtn}</button>
                <button class="stop-btn" id="stopBtn" onclick="handleStop()" disabled>${TEXTS.stopBtn}</button>
                <button class="next-btn" id="nextBtn" style="display:none;">${TEXTS.nextBtn}</button>
              </div>
            </div>
          `;
        },
        choices: [],
        on_load: function() {
          console.log(`\n=== Trial ${index + 1} started ===`);
          console.log(`Sentence: "${sentence}"`);
          audioChunks = [];
          isRecording = false;
          
          // ì „ì—­ í•¨ìˆ˜ë¡œ ë²„íŠ¼ í•¸ë“¤ëŸ¬ ì •ì˜
          window.handleRecord = async () => {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const statusEl = document.getElementById('status');
            
            if (isRecording) return;
            
            try {
              await startRecording();
              isRecording = true;
              
              recordBtn.disabled = true;
              stopBtn.disabled = false;
              
              if (statusEl) {
                statusEl.innerHTML = TEXTS.recording;
                statusEl.classList.add('recording-active');
              }
              
              // íƒ€ì´ë¨¸ ì‹œì‘
              let seconds = 0;
              currentTimerInterval = setInterval(() => {
                seconds++;
                const timerEl = document.getElementById('timer');
                if (timerEl) {
                  timerEl.textContent = `${seconds}ì´ˆ`;
                }
              }, 1000);
              
              console.log('Recording started');
            } catch (err) {
              console.error('Failed to start recording:', err);
              alert('ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨: ' + err.message);
            }
          };
          
          window.handleStop = async () => {
            const stopBtn = document.getElementById('stopBtn');
            const nextBtn = document.getElementById('nextBtn');
            const statusEl = document.getElementById('status');
            
            if (!isRecording) return;
            
            stopBtn.disabled = true;
            
            try {
              if (statusEl) {
                statusEl.innerHTML = 'ë…¹ìŒ ì¤‘ì§€ ì¤‘...';
                statusEl.classList.remove('recording-active');
              }
              
              await stopRecording();
              isRecording = false;
              
              // íƒ€ì´ë¨¸ ì •ì§€
              if (currentTimerInterval) {
                clearInterval(currentTimerInterval);
                currentTimerInterval = null;
              }
              
              console.log('Recording stopped, chunks:', audioChunks.length);
              
              // WAV ë³€í™˜ ë° ì—…ë¡œë“œ
              if (audioChunks.length > 0) {
                if (statusEl) {
                  statusEl.innerHTML = 'WAV ë³€í™˜ ì¤‘...';
                }
                
                const webmBlob = new Blob(audioChunks, { type: 'audio/webm' });
                console.log('WebM size:', webmBlob.size, 'bytes');
                
                const wavBlob = await convertWebMToWav(webmBlob);
                console.log('WAV size:', wavBlob.size, 'bytes');
                
                if (statusEl) {
                  statusEl.innerHTML = 'â³ ì„œë²„ì— ì—…ë¡œë“œ ì¤‘...';
                }
                
                const success = await uploadSingleRecording({
                  sentence: sentence,
                  index: index,
                  blob: wavBlob,
                  timestamp: new Date().toISOString()
                });
                
                if (success) {
                  console.log(`âœ“ Upload successful for trial ${index + 1}`);
                  if (statusEl) {
                    statusEl.innerHTML = 'âœ… ì—…ë¡œë“œ ì™„ë£Œ!';
                  }
                } else {
                  console.error(`âœ— Upload failed for trial ${index + 1}`);
                  if (statusEl) {
                    statusEl.innerHTML = 'âŒ ì—…ë¡œë“œ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.';
                  }
                }
              } else {
                if (statusEl) {
                  statusEl.innerHTML = 'âš ï¸ ë…¹ìŒëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
                }
              }
              
              // ë‹¤ìŒ ë²„íŠ¼ í‘œì‹œ
              if (nextBtn) {
                nextBtn.style.display = 'inline-block';
                nextBtn.onclick = () => {
                  jsPsych.finishTrial({
                    task: 'recording',
                    sentence: sentence,
                    sentence_index: index,
                    timestamp: new Date().toISOString()
                  });
                };
              }
              
            } catch (err) {
              console.error('Error during stop:', err);
              if (statusEl) {
                statusEl.innerHTML = 'âŒ ì˜¤ë¥˜: ' + err.message;
              }
              // ì—ëŸ¬ê°€ ë‚˜ë„ ë‹¤ìŒ ë²„íŠ¼ì€ ë³´ì—¬ì£¼ê¸°
              if (nextBtn) {
                nextBtn.style.display = 'inline-block';
                nextBtn.onclick = () => {
                  jsPsych.finishTrial({
                    task: 'recording',
                    sentence: sentence,
                    sentence_index: index,
                    error: err.message,
                    timestamp: new Date().toISOString()
                  });
                };
              }
            }
          };
        }
      };
    }

    /* ===== RECORDING FUNCTIONS ===== */
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            channelCount: 1,
            sampleRate: 16000
          } 
        });
        
        audioChunks = []; // ì´ˆê¸°í™”
        
        const options = { mimeType: 'audio/webm' };
        mediaRecorder = new MediaRecorder(stream, options);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
            console.log('Audio chunk received:', event.data.size, 'bytes');
          }
        };
        
        mediaRecorder.onerror = (event) => {
          console.error('MediaRecorder error:', event);
        };
        
        mediaRecorder.start(100); // 100msë§ˆë‹¤ ë°ì´í„° ìˆ˜ì§‘
        console.log('MediaRecorder started');
      } catch (err) {
        console.error('Recording start error:', err);
        throw err;
      }
    }

    function stopRecording() {
      return new Promise((resolve, reject) => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
          console.log('MediaRecorder already inactive');
          resolve();
          return;
        }
        
        const timeout = setTimeout(() => {
          reject(new Error('Recording stop timeout'));
        }, 5000);
        
        mediaRecorder.onstop = () => {
          clearTimeout(timeout);
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
          console.log('MediaRecorder stopped and tracks released');
          resolve();
        };
        
        try {
          mediaRecorder.stop();
        } catch (err) {
          clearTimeout(timeout);
          reject(err);
        }
      });
    }

    /* ===== WEBM TO WAV CONVERSION ===== */
    async function convertWebMToWav(webmBlob) {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await webmBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        console.log('Audio decoded:', {
          duration: audioBuffer.duration,
          sampleRate: audioBuffer.sampleRate,
          channels: audioBuffer.numberOfChannels
        });
        
        const wavBlob = audioBufferToWav(audioBuffer);
        await audioContext.close();
        
        return wavBlob;
      } catch (err) {
        console.error('WAV conversion error:', err);
        throw new Error('WAV ë³€í™˜ ì‹¤íŒ¨: ' + err.message);
      }
    }

    function audioBufferToWav(audioBuffer) {
      const numChannels = 1; // ëª¨ë…¸ë¡œ ë³€í™˜
      const sampleRate = audioBuffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;
      
      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;
      
      // ì²« ë²ˆì§¸ ì±„ë„ë§Œ ì‚¬ìš©
      const samples = audioBuffer.getChannelData(0);
      const dataLength = samples.length * blockAlign;
      
      const buffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(buffer);
      
      // WAV í—¤ë”
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataLength, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);
      
      // ì˜¤ë””ì˜¤ ë°ì´í„°
      const offset = 44;
      for (let i = 0; i < samples.length; i++) {
        const sample = Math.max(-1, Math.min(1, samples[i]));
        const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset + i * 2, int16, true);
      }
      
      return new Blob([buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    /* ===== GOOGLE DRIVE UPLOAD ===== */
    async function uploadSingleRecording(recordingData) {
      if (!GAS_ENDPOINT || GAS_ENDPOINT === 'YOUR_APPS_SCRIPT_URL') {
        console.error('Google Apps Script endpoint not configured!');
        alert('ì—…ë¡œë“œ ì‹¤íŒ¨: Google Apps Script URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return false;
      }

      if (!demographicsData) {
        console.error('Demographics data not available!');
        alert('ì°¸ê°€ì ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        return false;
      }

      try {
        const base64Audio = await blobToBase64(recordingData.blob);
        
        const payload = {
          participant_id: participantId,
          sentence_index: recordingData.index,
          sentence: recordingData.sentence,
          audio_data: base64Audio,
          timestamp: recordingData.timestamp,
          demographics: demographicsData
        };

        console.log('=== Uploading ===');
        console.log('Participant:', participantId);
        console.log('Sentence index:', recordingData.index);
        console.log('Audio size:', base64Audio.length, 'bytes (base64)');
        console.log('Demographics:', demographicsData);

        const response = await fetch(GAS_ENDPOINT, {
          method: 'POST',
          mode: 'no-cors', // CORS ë¬¸ì œ íšŒí”¼
          headers: { 
            'Content-Type': 'text/plain' // no-cors ëª¨ë“œì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ í—¤ë”
          },
          body: JSON.stringify(payload)
        });

        // no-cors ëª¨ë“œì—ì„œëŠ” ì‘ë‹µì„ ì½ì„ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì„±ê³µìœ¼ë¡œ ê°„ì£¼
        console.log('Upload request sent (no-cors mode)');
        return true;
        
      } catch (err) {
        console.error('Upload error:', err);
        alert(`ì—…ë¡œë“œ ì‹¤íŒ¨: ${err.message}`);
        return false;
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    /* ===== END ===== */
    const end = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.endTitle}</h2><p>${TEXTS.endBody}</p><p>ëª¨ë“  ë…¹ìŒ íŒŒì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</p>`,
      choices: [TEXTS.finishBtn]
    };

    /* ===== BUILD TIMELINE ===== */
    const recording_trials = SENTENCES.map((sentence, index) => 
      makeRecordingTrial(sentence, index)
    );

    /* ===== RUN ===== */
    console.log('Starting experiment...');
    jsPsych.run([
      welcome,
      demographics,        // ì¸ì ì‚¬í•­ ë¨¼ì €
      mic_permission,
      ...recording_trials, // ê·¸ ë‹¤ìŒ ë…¹ìŒ
      end
    ]);
  </script>
</body>
</html>
